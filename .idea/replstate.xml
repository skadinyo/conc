<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1431831894817">{:repl-history {:ide [], :local [&quot;(filter zero? [0 1 2])&quot; &quot;(rem 5 2)&quot; &quot;(na conc.alpha)&quot; &quot;(eul1-1 1000)&quot; &quot;(eul1-2l 1000)&quot; &quot;(eul1-2 100000)&quot; &quot;(eul1-1 100000)&quot; &quot;(time (eul1-1))&quot; &quot;(time (eul1-11000000000&quot; &quot;(time (eul1-1 100000000))&quot; &quot;(time (eul1-1 1000000))&quot; &quot;(r/re)&quot; &quot;(def x (ref 123))&quot; &quot;@x&quot; &quot;(swap! x + 1)&quot; &quot;(time (eul1-3 10000000))&quot; &quot;(time (eul1-2 10000000))&quot; &quot;(time (eul1-1 10000000))&quot; &quot;(ns conc.alpha)&quot; &quot;(slurp \&quot;./resources/problem-11.txt\&quot;)&quot; &quot;(-&gt;&gt; (slurp \&quot;./resources/problem-11.txt\&quot;)\n     (clojure.string/split-lines)\n     (map #(map int \n                (map str \n                     (clojure.string/split % #\&quot; \&quot;)))))&quot; &quot;(-&gt;&gt; (slurp \&quot;./resources/problem-11.txt\&quot;)\n     (clojure.string/split-lines)\n     (map (map (fn [a]\n                  (Integer/parseInt a))\n                (map str \n                     (clojure.string/split % #\&quot; \&quot;)))))&quot; &quot;(-&gt;&gt; (slurp \&quot;./resources/problem-11.txt\&quot;)\n     (clojure.string/split-lines)\n     (map #(map (fn [a]\n                  (Integer/parseInt a))\n                (map str \n                     (clojure.string/split % #\&quot; \&quot;)))))&quot; &quot;(-&gt;&gt; (slurp \&quot;./resources/problem-11.txt\&quot;)\n     (clojure.string/split-lines)\n     (mapv #(mapv (fn [a]\n                  (Integer/parseInt a))\n                (map str \n                     (clojure.string/split % #\&quot; \&quot;)))))&quot; &quot;(range 3 0 -1)&quot; &quot;(range 1 (+ 1 4))&quot; &quot;(range 4 0 -1)&quot; &quot;(range 3 -1 -1)&quot; &quot;(range 0 5)&quot; &quot;(range 0 4)&quot; &quot;(count (eul-11))&quot; &quot;(map #(get-in (eul-11) [0 %])\n     (range 0 4))&quot; &quot;(eul-11)&quot; &quot;(eul-11-1)&quot; &quot;(time (eul-11-1))&quot; &quot;(reduce *' (m/primes-to 20))&quot; &quot;(reduce *' (m/primes-to 500))&quot; &quot;(reduce *' (m/primes-to 52))&quot; &quot;(eul-5-1 500)&quot; &quot;(eul-5-1 200)&quot; &quot;(eul-5-1 100)&quot; &quot;(eul-5-1 10)&quot; &quot;(eul-5-1 20)&quot; &quot;(eul-5-1 30)&quot; &quot;(count-div 6 2)&quot; &quot;(let [x (int-array 2 [[1 2] [3 2]])]\n  (vec x))&quot; &quot;(let [x (int-array 2 [2 3])]\n  (vec x))&quot; &quot;(let [x (array 2 [2 3])]\n  (vec x))&quot; &quot;(let [x (array-map 2 [{}])]\n  (vec x))&quot; &quot;(let [x (array-map [{}])]\n  (vec x))&quot; &quot;(let [x (array-map 2 [{} {}])]\n  (vec x))&quot; &quot;(let [x [[] [] []]\n      xr (into-array x)]\n  (vec x))&quot; &quot;(repeat 10 [])&quot; &quot;(let [x (repeat 10 [])\n      xr (into-array x)]\n  (vec x))&quot; &quot;(let [x (repeat 10 {})\n      xr (into-array x)]\n  (vec x))&quot; &quot;(count-div 2 6)&quot; &quot;(vals {})&quot; &quot;(int-array [1 2 3])&quot; &quot;(def asdam (int-array [1 2 3]))&quot; &quot;(vec asdam)&quot; &quot;(vals {:a 2 :s 3})&quot; &quot;(vals {:a 2})&quot; &quot;(take 100 (gen-tri))&quot; &quot;(eul-12-1 10)&quot;], :remote []}}</component>
</project>